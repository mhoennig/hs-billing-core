= Hostsharing Billing Core
Michael Hönnig
2020-12-03
:icons: font

CAUTION: This software is under development and not yet usable.

This program is the core module of _Hostsharing_'s billing system.
It's based on snapshot input CSV-files, supplied by other modules and creates a set of output-files like accounting records and invoices.
These outputs are processed by subsequent steps, like mailing the invoices to the customers.

Executions are idempotent and therefore repeatable:
As long as the parameters and input files are the same, each run will produce exactly the same output.

== Architecture Overview

=== Input Files

The input-CSV-files, supplied by other modules are:

- `customer.csv` - containing customer data like billing-contact and payment mode
- multiple `*-billing-items.csv` - containing items to be invoiced from multiple sources
- `vat-groups.csv` - specifies

=== Output Files

For each run it creates a set of output files through _Velocity_ templates:

- `accounting-records.csv` - accounting records including VAT-specific account numbers to be further processed by the accounting system
- invoices in several formats like for emails and PDF-generation (not implemented yet)
- `sepa.csv` - contains records for direct debiting
- ...

=== Package Structure

The root-package of this program `org.hostsharing.hsadmin.billing.core` contains the main program.

The main program orchestrates the following modules.

It contains the following sub-packages:

`domain`::
Types describing the domain model.

`reader`::
Classes and functions which read and parse the input CSV-file and convert these into domain-objects.

`invoicing`::
Actual "calculation" of the invoices using the domain objects from the `reader`.
The output is an internal presentation of the invoices.

`generator`::
These generators take the internal  presentation of the invoices from the `invoicing` module and produce output domain objects for further processing by the `writer`

`writer`::
Functions which convert the generated domain objects to be used as contexts in _Velocity_ templates which then are used to generate the output files.

`lib`::
Types functions which can be used in all other modules.


== Quality Assurance

=== Code-Formatting and Linting

The general formatting of files is defined in `.editorconfig`, these settings should automatically be picked up by most code editors and IDSs.

Also, _ktlint_ is installed and configured.
To check code style, run:

[source,shell script]
----
$ ./gradlew ktlint
----

This task also bound to "gradle check".

To automatically fix code style deviations, use:

[source,shell script]
----
$ ./gradlew ktlintFormat
----

=== Code Complexity

For checking code complexity _detekt_ is configured:

[source,shell script]
----
$ ./gradlew detekt
----

This command will check for rule violations and create a link:app/build/reports/detekt.html[report].

For more information see https://detekt.github.io/detekt/gradle.html#available-plugin-tasks[_detekt_ project on _Github_].


=== Unit Testing

For unit-testing, _JUnit 5 (Jupiter)__ is used along with _assertk_, a _Kotlin_ version of _assertj_ as a check task for gradle.

To execute the unit-tests, run:

[source,shell script]
----
$ ./gradlew test
----

For writing unit-tests consider the __BRIEF__ rules http://gasparnagy.com/2019/05/clean-up-bad-bdd-scenarios/[from BDD]:

Business language::
enables collaboration and feedback

Real data::
helps to discover white spots in requirements

Intention revealing::

is a way to describe the tests by focusing on what we wanted to achieve and not on how

Essential::
include only relevant details in the scenario

Focused::
the scenarios should illustrate a single rule only
Brief — keep scenarios short


=== Architecture Verification

There is some automatic verification of architecture rules using __ArchUnit__ in the unit test `ArchitectureTest`.
See there for more information, especially about the git branch `archunit-rule-validation` and verifying the rules themselves.

Technically this is a mal unit-test, thus run with:

[source,shell script]
----
$ ./gradlew test
----


=== Mutation Testing

To check the quality of the assertions in the unit-tests, https://pitest.org/[_pitest_] is used as a https://en.wikipedia.org/wiki/Mutation_testing[mutation testing]-tool.

The mutation-tests can be executed with:

[source,shell script]
----
$ ./gradlew pitest
----

This creates link:./app/build/reports/pitest/org.hostsharing.hsadmin.billing.core.reader/index.html[a report] comprising line- and mutation-coverage of the unit-tests.

If the "mutant-kill rate" falls below a configured limit, the _pitest_-task  will fail;
in that case, please improve the unit-tests.
The limits are configured in `app/build.gradle`.
Please increase the limit according to the level we have reached, once we become better;
about 2 percent points below the level we have actually reached, is a good measure.

CAUTION: After a successful run, you can see percentage  which actually counts for the limit.
The percentage shown in the report HTML-file seems to be calculated differently and is usually a bit higher.
